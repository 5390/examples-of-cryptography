package main

import (
	asymmetrickey "examples-of-cryptography/cryptography/asymmetric-key"
	symmetrickey "examples-of-cryptography/cryptography/symmetric-key"
	hashing "examples-of-cryptography/hashing"
	keyexchangealgorithms "examples-of-cryptography/key-exchange-algorithms"
	postquantumcryptography "examples-of-cryptography/post-quantum-cryptography"
	"fmt"
)

func main() {

	fmt.Println("==================================== Symmetric key AES Example ==============================")
	// Secret Key (16, 24, or 32 bytes for AES-128, AES-192, AES-256)
	// 32 bytes for AES-256
	// Plain text
	// Encrypt
	// Decrypt
	symmetrickey.AESExample()

	fmt.Println("==================================== Asymmetric Key RSA Example ==============================")
	// RSAExample demonstrates the process of generating an RSA key pair,
	// encrypting a message using the public key, and decrypting it using
	// the private key. The function includes the following steps:
	// 1. Generate a new RSA key pair (2048-bit).
	// 2. Encode the private key in PEM format and print it.
	// 3. Encrypt a message using the public key.
	// 4. Decrypt the encrypted message using the private key.
	// It prints the generated private key, encrypted message (in hexadecimal),
	// and the decrypted message to the console.
	asymmetrickey.RSAExample()

	fmt.Println("==================================== Hashing SHA-256 ==============================")
	// Sha256Example demonstrates the process of hashing a string using SHA-256.
	// It takes a sample string, "Hello, Hashing with SHA-256!", and computes its SHA-256 hash.
	// The function then prints the original text and its corresponding SHA-256 hash in hexadecimal format.
	hashing.Sha256Example()
	fmt.Println("==================================== Key Exchange Algorithms ECDH==============================")
	// Sha256Example demonstrates the process of hashing a string using SHA-256.
	// It takes a sample string, "Hello, Hashing with SHA-256!", and computes its SHA-256 hash.
	// The function then prints the original text and its corresponding SHA-256 hash in hexadecimal format.
	keyexchangealgorithms.KeyExchangeExampleECDH()

	fmt.Println("==================================== post-quantum-cryptography Dilithium Example ==============================")

	// DilithiumKeyGeneration generates a public and secret key pair for Dilithium schemes (Dilithium2, Dilithium3, Dilithium5)
	// based on the provided seed and compares the resulting key hashes with the expected values.
	//
	// The function performs the following steps:
	// 1. Selects the appropriate Dilithium scheme based on the provided scheme name (Dilithium2, Dilithium3, or Dilithium5).
	// 2. Uses a static 32-byte seed to generate the key pair (both public and private keys) using the selected scheme.
	// 3. Marshals the keys into binary format.
	// 4. Hashes the generated public and private keys using SHA3-256 (Shake256 variant).
	// 5. Compares the hashed values with the provided expected public and secret key hashes.
	// 6. If the generated hashes match the expected values, the function prints a success message.
	// 7. If the hashes do not match, the function logs an error and terminates.
	//
	// Parameters:
	// - schemeName: The name of the Dilithium scheme to use ("Dilithium2", "Dilithium3", "Dilithium5").
	// - expectedPublicKeyHex: The expected hash of the public key, in hexadecimal format.
	// - expectedSecretKeyHex: The expected hash of the secret key, in hexadecimal format.
	postquantumcryptography.DilithiumKeyGeneration("Dilithium2", "7522162619f3329b5312322d3ee45b87", "afe2e91f5f5899354230744c18410498")

	fmt.Println("==================================== post-quantum-cryptography Kyber Example ==============================")

	// KyberExample demonstrates the use of the Kyber post-quantum key encapsulation mechanism (KEM) for secure key exchange.
	// It performs the following steps:
	// 1. Selects the Kyber scheme (Kyber512, Kyber768, or Kyber1024) based on the provided string.
	// 2. Generates a public/private key pair for the recipient using the selected Kyber scheme.
	// 3. Encapsulates a shared secret and ciphertext by the sender using the recipient's public key.
	// 4. Decapsulates the shared secret using the recipient's private key.
	// 5. Compares the shared secrets generated by the sender and the recipient to ensure they match and confirms the success of the key exchange.
	// Errors during any step (key generation, encapsulation, or decapsulation) will terminate the program with an appropriate error message.
	postquantumcryptography.KyberExample()

}

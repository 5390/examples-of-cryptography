package main

import (
	"examples-of-cryptography/blockchain/hyperledger"
	asymmetrickey "examples-of-cryptography/cryptography/asymmetric-key"
	hashing "examples-of-cryptography/cryptography/hashing"
	keyexchangealgorithms "examples-of-cryptography/cryptography/key-exchange-algorithms"
	postquantumcryptography "examples-of-cryptography/cryptography/post-quantum-cryptography"
	symmetrickey "examples-of-cryptography/cryptography/symmetric-key"
	"fmt"
)

func main() {

	fmt.Println("==================================== Symmetric key AES Example ==============================")
	// Secret Key (16, 24, or 32 bytes for AES-128, AES-192, AES-256)
	// 32 bytes for AES-256
	// Plain text
	// Encrypt
	// Decrypt
	symmetrickey.AESExample()

	fmt.Println("==================================== Asymmetric Key RSA Example ==============================")
	// RSAExample demonstrates the process of generating an RSA key pair,
	// encrypting a message using the public key, and decrypting it using
	// the private key. The function includes the following steps:
	// 1. Generate a new RSA key pair (2048-bit).
	// 2. Encode the private key in PEM format and print it.
	// 3. Encrypt a message using the public key.
	// 4. Decrypt the encrypted message using the private key.
	// It prints the generated private key, encrypted message (in hexadecimal),
	// and the decrypted message to the console.
	asymmetrickey.RSAExample()

	fmt.Println("==================================== Hashing SHA-256 ==============================")
	// Sha256Example demonstrates the process of hashing a string using SHA-256.
	// It takes a sample string, "Hello, Hashing with SHA-256!", and computes its SHA-256 hash.
	// The function then prints the original text and its corresponding SHA-256 hash in hexadecimal format.
	hashing.Sha256Example()
	fmt.Println("==================================== Key Exchange Algorithms ECDH==============================")
	// Sha256Example demonstrates the process of hashing a string using SHA-256.
	// It takes a sample string, "Hello, Hashing with SHA-256!", and computes its SHA-256 hash.
	// The function then prints the original text and its corresponding SHA-256 hash in hexadecimal format.
	keyexchangealgorithms.KeyExchangeExampleECDH()

	fmt.Println("==================================== post-quantum-cryptography Dilithium Example ==============================")

	// DilithiumKeyGeneration generates a public and secret key pair for Dilithium schemes (Dilithium2, Dilithium3, Dilithium5)
	// based on the provided seed and compares the resulting key hashes with the expected values.
	//
	// The function performs the following steps:
	// 1. Selects the appropriate Dilithium scheme based on the provided scheme name (Dilithium2, Dilithium3, or Dilithium5).
	// 2. Uses a static 32-byte seed to generate the key pair (both public and private keys) using the selected scheme.
	// 3. Marshals the keys into binary format.
	// 4. Hashes the generated public and private keys using SHA3-256 (Shake256 variant).
	// 5. Compares the hashed values with the provided expected public and secret key hashes.
	// 6. If the generated hashes match the expected values, the function prints a success message.
	// 7. If the hashes do not match, the function logs an error and terminates.
	//
	// Parameters:
	// - schemeName: The name of the Dilithium scheme to use ("Dilithium2", "Dilithium3", "Dilithium5").
	// - expectedPublicKeyHex: The expected hash of the public key, in hexadecimal format.
	// - expectedSecretKeyHex: The expected hash of the secret key, in hexadecimal format.
	postquantumcryptography.DilithiumKeyGeneration("Dilithium2", "7522162619f3329b5312322d3ee45b87", "afe2e91f5f5899354230744c18410498")

	fmt.Println("==================================== post-quantum-cryptography Kyber Example ==============================")

	// KyberExample demonstrates the use of the Kyber post-quantum key encapsulation mechanism (KEM) for secure key exchange.
	// It performs the following steps:
	// 1. Selects the Kyber scheme (Kyber512, Kyber768, or Kyber1024) based on the provided string.
	// 2. Generates a public/private key pair for the recipient using the selected Kyber scheme.
	// 3. Encapsulates a shared secret and ciphertext by the sender using the recipient's public key.
	// 4. Decapsulates the shared secret using the recipient's private key.
	// 5. Compares the shared secrets generated by the sender and the recipient to ensure they match and confirms the success of the key exchange.
	// Errors during any step (key generation, encapsulation, or decapsulation) will terminate the program with an appropriate error message.
	postquantumcryptography.KyberExample()

	fmt.Println("==================================== Blockchain Hyperledger Fabric Example ==============================")
	// FabricExample initializes and starts the Hyperledger Fabric chaincode.
	// This function creates an instance of the SmartContract and starts it, enabling it to process transactions.
	//
	// Steps performed:
	// 1. Creates a new chaincode instance using the `SmartContract` implementation.
	// 2. Handles errors during chaincode creation or startup.
	// 3. Starts the chaincode, allowing the Fabric network to invoke its functions.
	//
	// Usage:
	// - This function is the entry point for deploying the chaincode.
	// - Once started, the chaincode listens for transaction proposals from peers.
	//
	// Note: If there is an error during initialization or startup, it prints the error and exits.
	hyperledger.FabricExample()

	fmt.Println("==================================== Blockchain Hyperledger Solana Example ==============================")
	// SolanaExample simulates a simplified Solana consensus process using leader rotation and voting.
	// It demonstrates:
	// 1. **Leader Rotation**: Validators take turns acting as leaders to propose blocks. This mimics Solana's leader-based Proof of History (PoH) mechanism.
	// 2. **Voting**: Validators cast votes (yes/no) on the proposed blocks, simulating Solana's Tower BFT consensus mechanism.
	//
	// The function performs the following steps:
	// - Creates a set of validators, each identified by a unique ID.
	// - Simulates leader rotation, where each validator acts as the leader to generate a block.
	// - Simulates voting, where all validators cast votes on the proposed blocks.
	// - Outputs the status of block generation and voting to showcase the consensus flow.
	//
	// This simulation uses Go's concurrency model (goroutines and WaitGroup) to mimic the parallelism and real-time behavior of validators in a Solana-like blockchain network.
	//
	// Note: This is a simplified example intended for learning purposes and does not reflect the full complexity of Solana's implementation.
	hyperledger.SolanaExample()

}
